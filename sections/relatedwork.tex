\section{Verwandte Forschungsarbeiten}\label{chap:relatedwork}

%%%%%%%%%%%%%%%%
%
%   Related Work
%
%%%%%%%%%%%%%%%%

Relevante Testdaten sind in verschiedenen Phasen im Entwicklungsprozess einer Anwendung von hoher Wichtigkeit.
Um Geschäftsanwendungen zu testen, gibt es neben dem Mittel, die Datenbankanbindung zu mocken \cite{Taneja:2010:MAT:1858996.1859053} auch die Möglichkeit, sie direkt mit einzubeziehen.
Bei diesem Ansatz werden die Eingabewerte der Tests mit dem Zustand der Datenbank in Verbindung gebracht.
Dazu gibt es verschiedene Vorgehensweisen.

\subsection{Eingabewerte zum Testen von Datenbankanwendungen}
Mit dem Erzeugen relevanter Eingabewerte für funktionale Anwendungstests hat sich in den letzten Jahren eine Reihe von Forschungsprojekten beschäftigt.
Der Fokus der nachfolgend beschriebenen Ansätze liegt dabei, im Kontrast zu dieser Bachelorarbeit, auf der Abdeckung und Zweigüberdeckung von Anwendungstests durch Einbeziehung des Status der Datenbank.

Im Sektor Datenbankanwendungstests bietet das AGENDA-Framework \cite{Chays:2000:FTD:347324.348954, Chays:2004:TDG:997669, Chays:2004:ATR:1077269.1077271, Deng:2005:TDT:1062455.1062486, Chays:2008:QTG:1385269.1385277} eine Palette an Werkzeugen für das funktionale Testen.
Es nutzt die Metainformationen der Datenbank in Kombination mit Voreinstellungen vom Entwickler, um eine Testdatenbank synthetisch zu erzeugen.
Mithilfe dieser Datenbank wird die Quellcodeabdeckung der funktionalen Tests erhöht.
Im Gegensatz dazu, liegt der Schwerpunkt dieser Bachelorarbeit auf dem nicht-funktionalen Testen der Performance der Anwendung anhand von Echtdaten.
Dabei werden ähnlich dem AGENDA-Framework auch die Metainformationen der Datenbank mit einbezogen.

Auf Basis von Microsofts Testing-Framework Pex für die .Net-Plattform \cite{Tillmann:2008:PWB:1792786.1792798} entwickelten Pan et al. mehrere Erweiterungen \cite{Pan:2011:GPI:2190078.2190154, Pan:2011:DSG:1988842.1988846}, die die Quellcodeabdeckung durch Einbeziehung der Datenbank und ihrer Daten erhöhen.
Dabei werden mittels Dynamic Symbolic Execution (DSE) \cite{Cadar:2006:EAG:1180405.1180445, Godefroid:2005:DDA:1065010.1065036} sowohl die Variablen, die in SQL-Statements einfließen, als auch ihre Änderungen im Programmfluss nachverfolgt, um daraus passende Eingaben zu generieren \cite{Pan:2011:GPI:2190078.2190154}.
Durch die zusätzlichen Anforderungen an Logical Coverage (LC) \cite{DBLP:conf/issre/AmmannOH03} und Boundary Value Coverage (BVC) \cite{DBLP:conf/issre/KosmatovLPU04} werden die gefunden Variablen im Zusammenhang mit Bedingungen innerhalb der Anwendung betrachtet, wodurch gegebenenfalls weitere Eingabewerte erzeugt werden.

Der Ansatz der symbolischen Ausführung ist auch in die Implementierung der Web-IDE eingeflossen, um die zu betrachtenden Abhängigkeiten von Datenbankzugriffen zu ermitteln.
Ebenso findet in den Ansätzen dieser Bachelorarbeit zur Ermittlung der verschiedenen Ausprägungen von SQL-Statements eine Betrachtung von Bedingungen innerhalb des Kontrollflusses statt.

\subsection{Liveanalyse von Datenbankanwendungen}
Das Monitoring ist eine alternative Möglichkeit, die Performance einer Datenbankanwendung zu ermitteln.
Softwarelösungen wie New Relic\footnote{\url{http://newrelic.com/}} betten eigene Komponenten in Anwendungen ein, um Metriken aus dem laufenden Betrieb aufzunehmen und zu analysieren.
Sie können dann unter anderem die langsamsten SQL-Statements mitsamt ihren Parametern dem Entwickler anzeigen.
Für dieses Verfahren ist es allerdings erforderlich, dass SQL-Statements vollständig erfasst und ihre variablen Bestandteile mit Werten gefüllt sind.
Die vorgestellte Entwicklungsumgebung ermöglicht es hingegen, schon in der Entwicklungsphase auch partielle Datenbankabfragen zu analysieren und mit verschiedenen Werten zu testen.
Eine Erweiterung der vorgestellten Algorithmen, Parameter aus den Ausführungsdaten zu extrahieren, würde beide Ideen kombinieren.
So könnten häufig genutzte Werte aus dem Betrieb für Vorschläge von Testdaten zur Weiterentwicklung der Anwendung genutzt werden.

%\subsection{Performance-Test-Frameworks}
%TODO: Übersichtstabelle mit Einordnung der eigenen Lösung